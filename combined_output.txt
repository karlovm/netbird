
// main\bookmark-manager.js

const Store = require('electron-store');

class BookmarkManager {
    constructor() {
        this.store = new Store({
            name: 'bookmarks',
            defaults: {
                bookmarks: []
            }
        });
    }

    addBookmark(url, title, folder = 'default') {
        const bookmarks = this.store.get('bookmarks', []);
        const bookmark = {
            id: this.generateId(),
            url,
            title,
            folder,
            timestamp: Date.now()
        };

        bookmarks.push(bookmark);
        this.store.set('bookmarks', bookmarks);
        return bookmark;
    }

    getBookmarks() {
        return this.store.get('bookmarks', []);
    }

    removeBookmark(id) {
        const bookmarks = this.store.get('bookmarks', []);
        const filteredBookmarks = bookmarks.filter(bookmark => bookmark.id !== id);
        this.store.set('bookmarks', filteredBookmarks);
    }

    updateBookmark(id, updates) {
        const bookmarks = this.store.get('bookmarks', []);
        const index = bookmarks.findIndex(bookmark => bookmark.id === id);
        
        if (index >= 0) {
            bookmarks[index] = { ...bookmarks[index], ...updates };
            this.store.set('bookmarks', bookmarks);
            return bookmarks[index];
        }
        
        return null;
    }

    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
}

module.exports = BookmarkManager;


// main\extension-manager.js

const fs = require('fs');
const path = require('path');
const { session, BrowserWindow, protocol, app } = require('electron');

class ExtensionManager {
    constructor(userDataPath = null) {
        this.extensions = new Map();
        this.loadedExtensions = new Set();
        this.popupWindows = new Map();
        this.extensionStores = new Map();
        this.registeredProtocols = new Set();
        
        // Set up persistence
        this.userDataPath = userDataPath || app.getPath('userData');
        this.extensionsConfigPath = path.join(this.userDataPath, 'extensions.json');
        this.extensionsDataPath = path.join(this.userDataPath, 'extensions');
        
        // Ensure extensions directory exists
        if (!fs.existsSync(this.extensionsDataPath)) {
            fs.mkdirSync(this.extensionsDataPath, { recursive: true });
        }
        
        this.setupExtensionAPIs();
       
    }

    // Load extensions from saved configuration
    async initializeFromConfig() {
        try {
            if (fs.existsSync(this.extensionsConfigPath)) {
                const configData = fs.readFileSync(this.extensionsConfigPath, 'utf8');
                const config = JSON.parse(configData);
                
                console.log('Loading saved extensions configuration...');
                
                for (const extensionConfig of config.extensions || []) {
                    try {
                        // Check if extension path still exists
                        if (fs.existsSync(extensionConfig.path)) {
                            console.log(`Restoring extension: ${extensionConfig.name}`);
                            await this.loadExtension(extensionConfig.path);
                        } else {
                            console.warn(`Extension path no longer exists: ${extensionConfig.path}`);
                        }
                    } catch (error) {
                        console.error(`Failed to restore extension ${extensionConfig.name}:`, error);
                    }
                }
                
                console.log('Extension restoration complete');
            } else {
                console.log('No saved extensions configuration found');
            }
        } catch (error) {
            console.error('Failed to load extensions configuration:', error);
        }
    }

    // Save current extensions configuration
    saveConfiguration() {
        try {
            const config = {
                extensions: Array.from(this.extensions.values()).map(ext => ({
                    id: ext.id,
                    name: ext.name,
                    version: ext.version,
                    path: ext.path,
                    enabled: ext.enabled
                })),
                lastUpdated: new Date().toISOString()
            };
            
            fs.writeFileSync(this.extensionsConfigPath, JSON.stringify(config, null, 2));
            console.log('Extensions configuration saved');
        } catch (error) {
            console.error('Failed to save extensions configuration:', error);
        }
    }

    getExtensionStore(extensionId) {
        if (!this.extensionStores.has(extensionId)) {
            const Store = require('electron-store');
            this.extensionStores.set(extensionId, new Store({
                name: `extension_${extensionId}_storage`,
                defaults: {},
                cwd: this.extensionsDataPath
            }));
        }
        return this.extensionStores.get(extensionId);
    }

    async getStorage(extensionId, keys) {
        const store = this.getExtensionStore(extensionId);
        if (!keys) return store.store;
        if (typeof keys === 'string') return { [keys]: store.get(keys) ?? null };
        if (Array.isArray(keys)) {
            const result = {};
            keys.forEach(key => result[key] = store.get(key) ?? null);
            return result;
        }
        const result = {};
        for (const key in keys) {
            result[key] = store.get(key, keys[key]) ?? null;
        }
        return result;
    }

    async setStorage(extensionId, items) {
        const store = this.getExtensionStore(extensionId);
        for (const key in items) {
            store.set(key, items[key]);
        }
    }

    setupExtensionAPIs() {
        if (!this.schemesRegistered) {
            try {
                protocol.registerSchemesAsPrivileged([
                    {
                        scheme: 'chrome-extension',
                        privileges: {
                            standard: true,
                            secure: true,
                            allowServiceWorkers: true,
                            supportFetchAPI: true
                        }
                    }
                ]);
                this.schemesRegistered = true;
                console.log('Extension schemes registered');
            } catch (error) {
                console.error('Failed to register extension schemes:', error);
            }
        }
    }

    async injectExtensionAPIs(webContents, extension, currentUrl = '', isPopup = false) {
        try {
            if (!webContents || webContents.isDestroyed()) {
                console.warn('WebContents is destroyed, skipping API injection');
                return;
            }

            const safeExtension = JSON.parse(JSON.stringify(extension));
            console.log('Injecting APIs for extension:', safeExtension.id);

            if (!safeExtension.manifest || typeof safeExtension.manifest !== 'object') {
                throw new Error('Invalid extension manifest');
            }

            let manifestString;
            try {
                manifestString = JSON.stringify(safeExtension.manifest);
            } catch (error) {
                console.error('Failed to stringify manifest for extension:', safeExtension.id, error);
                throw new Error(`Failed to serialize manifest: ${error.message}`);
            }

            const escapedCurrentUrl = currentUrl.replace(/'/g, "\\'");

            let apiScript = `
            (function() {
                try {
                    // Prevent double injection
                    if (window.chrome && window.chrome._extensionId === '${safeExtension.id}') {
                        console.log('Extension APIs already injected for ${safeExtension.id}');
                        return;
                    }
                    
                    console.log('Injecting extension APIs for ${safeExtension.id}');
                    
                    window.chrome = window.chrome || {};
                    window.chrome._extensionId = '${safeExtension.id}';
                    window.chrome._injectedAt = Date.now();
            `;

            if (!extension.electronId) {
                apiScript += `
                    // Runtime APIs
                    window.chrome.runtime = window.chrome.runtime || {};
                    window.chrome.runtime.id = '${safeExtension.id}';
                    window.chrome.runtime.getManifest = function() {
                        return ${manifestString};
                    };
                    window.chrome.runtime.getURL = function(path) {
                        return 'chrome-extension-${safeExtension.id}://' + path;
                    };
                    window.chrome.runtime.sendMessage = function(message, callback) {
                        console.log('Extension message:', message);
                        if (callback) {
                            setTimeout(() => callback({}), 0);
                        }
                        return Promise.resolve({});
                    };
                    
                    // Extension APIs
                    window.chrome.extension = window.chrome.extension || {};
                    window.chrome.extension.getURL = window.chrome.runtime.getURL;
                    
                    // i18n APIs
                    window.chrome.i18n = window.chrome.i18n || {};
                    window.chrome.i18n.getMessage = function(key, substitutions) {
                        return key;
                    };
                    
                    // Storage APIs
                    window.chrome.storage = window.chrome.storage || {};
                    window.chrome.storage.local = window.chrome.storage.local || {};
                    
                    window.chrome.storage.local.get = function(...args) {
                        let keys = null, callback = null;
                        
                        if (args.length === 0) {
                            keys = null;
                        } else if (args.length === 1) {
                            if (typeof args[0] === 'function') {
                                callback = args[0];
                                keys = null;
                            } else {
                                keys = args[0];
                            }
                        } else if (args.length === 2) {
                            keys = args[0];
                            callback = args[1];
                        }
                        
                        const handleResult = (result) => {
                            if (callback) {
                                setTimeout(() => callback(result), 0);
                            }
                            return result;
                        };
                        
                        if (window.electronAPI && window.electronAPI.extensionStorageGet) {
                            const promise = window.electronAPI.extensionStorageGet('${safeExtension.id}', keys);
                            if (callback) {
                                promise.then(handleResult).catch(err => {
                                    console.error('Storage get error:', err);
                                    handleResult({});
                                });
                                return;
                            }
                            return promise;
                        } else {
                            const result = {};
                            return Promise.resolve(handleResult(result));
                        }
                    };
                    
                    window.chrome.storage.local.set = function(...args) {
                        let items = args[0] || {}, callback = args[1];
                        
                        if (args.length === 1 && typeof args[0] === 'function') {
                            callback = args[0];
                            items = {};
                        }
                        
                        const handleSuccess = () => {
                            if (callback) {
                                setTimeout(callback, 0);
                            }
                        };
                        
                        if (window.electronAPI && window.electronAPI.extensionStorageSet) {
                            const promise = window.electronAPI.extensionStorageSet('${safeExtension.id}', items);
                            if (callback) {
                                promise.then(handleSuccess).catch(err => {
                                    console.error('Storage set error:', err);
                                    handleSuccess();
                                });
                                return;
                            }
                            return promise;
                        } else {
                            setTimeout(handleSuccess, 0);
                            return Promise.resolve();
                        }
                    };
                    
                    window.chrome.storage.local.remove = function(keys, callback) {
                        // Simple implementation - in real scenario, you'd implement this in the main process
                        if (callback) {
                            setTimeout(callback, 0);
                        }
                        return Promise.resolve();
                    };
                    
                    window.chrome.storage.local.clear = function(callback) {
                        // Simple implementation - in real scenario, you'd implement this in the main process
                        if (callback) {
                            setTimeout(callback, 0);
                        }
                        return Promise.resolve();
                    };
                    
                    // Browser compatibility
                    if (!window.browser) {
                        window.browser = window.chrome;
                    }
                `;
            }

            apiScript += `
                    // Tabs API
                    window.chrome.tabs = window.chrome.tabs || {};
                    window.chrome.tabs.query = function(queryInfo, callback) {
                        if (typeof queryInfo === 'function') {
                            callback = queryInfo;
                            queryInfo = {};
                        }
                        
                        const getCurrentTab = () => {
                            const currentUrl = '${escapedCurrentUrl}';
                            const tabs = [];
                            
                            if (queryInfo.active !== false && queryInfo.currentWindow !== false && currentUrl) {
                                tabs.push({
                                    id: 1,
                                    index: 0,
                                    windowId: 1,
                                    active: true,
                                    url: currentUrl,
                                    title: document.title || 'Current Tab',
                                    favIconUrl: '',
                                    status: 'complete'
                                });
                            }
                            
                            return tabs;
                        };
                        
                        const result = getCurrentTab();
                        if (callback) {
                            setTimeout(() => callback(result), 0);
                        }
                        return Promise.resolve(result);
                    };
                    
                    window.chrome.tabs.getCurrent = function(callback) {
                        const result = undefined; // Content scripts don't have current tab
                        if (callback) {
                            setTimeout(() => callback(result), 0);
                        }
                        return Promise.resolve(result);
                    };
                    
                    console.log('Extension APIs successfully injected for ${safeExtension.id}');
                    
                } catch (error) {
                    console.error('Extension API injection failed for ${safeExtension.id}:', error);
                }
            })();
            `;

            await webContents.executeJavaScript(apiScript);
            console.log('Successfully injected APIs for extension:', safeExtension.id);
        } catch (error) {
            console.error('Failed to inject extension APIs for extension:', extension.id, error);
            throw error;
        }
    }

    async loadExtension(extensionPath) {
        try {
            const manifestPath = path.join(extensionPath, 'manifest.json');

            if (!fs.existsSync(manifestPath)) {
                throw new Error('manifest.json not found');
            }

            const manifestRaw = fs.readFileSync(manifestPath, 'utf8');
            let manifest;
            try {
                manifest = JSON.parse(manifestRaw);
            } catch (error) {
                throw new Error(`Invalid manifest.json: ${error.message}`);
            }

            if (!manifest.name || !manifest.version) {
                throw new Error('Invalid manifest.json: missing name or version');
            }

            const extensionId = this.generateExtensionId(manifest.name);

            // Check if extension is already loaded
            if (this.extensions.has(extensionId)) {
                console.log('Extension already loaded, unloading first:', extensionId);
                await this.unloadExtension(extensionId);
            }

            const safeManifest = JSON.parse(JSON.stringify(manifest, (key, value) => {
                if (typeof value === 'function' || value === undefined) {
                    return undefined;
                }
                return value;
            }));

            const extension = {
                id: extensionId,
                name: manifest.name,
                version: manifest.version,
                description: manifest.description || '',
                path: extensionPath,
                manifest: safeManifest,
                enabled: true,
                icon: this.getExtensionIcon(extensionPath, safeManifest),
                popup: manifest.browser_action?.default_popup || manifest.action?.default_popup,
                loadedAt: new Date().toISOString()
            };

            // Try to load with Electron's extension system
            try {
                const loadedExtension = await session.defaultSession.loadExtension(extensionPath, {
                    allowFileAccess: true
                });
                extension.electronId = loadedExtension.id;
                console.log('Extension loaded with Electron ID:', loadedExtension.id);
            } catch (electronError) {
                console.warn('Failed to load extension with Electron session, using manual loading:', electronError.message);
            }

            this.extensions.set(extension.id, extension);
            this.loadedExtensions.add(extension.id);

            await this.setupExtensionProtocol(extension);

            // Save configuration after successful load
            this.saveConfiguration();

            console.log('Extension loaded successfully:', extension.name, 'v' + extension.version);
            return JSON.parse(JSON.stringify(extension));
        } catch (error) {
            console.error('Failed to load extension:', error);
            throw error;
        }
    }

    getExtensionIcon(extensionPath, manifest) {
        let iconRelativePath = null;

        if (manifest.icons) {
            const sizes = Object.keys(manifest.icons).map(Number).sort((a, b) => b - a);
            const largestSize = sizes[0];
            if (largestSize) {
                iconRelativePath = manifest.icons[largestSize];
            }
        } else if (manifest.browser_action?.default_icon) {
            const iconInfo = manifest.browser_action.default_icon;
            if (typeof iconInfo === 'string') {
                iconRelativePath = iconInfo;
            } else if (typeof iconInfo === 'object') {
                const sizes = Object.keys(iconInfo).map(Number).sort((a, b) => b - a);
                const largestSize = sizes[0];
                if (largestSize) {
                    iconRelativePath = iconInfo[largestSize];
                }
            }
        } else if (manifest.action?.default_icon) {
            const iconInfo = manifest.action.default_icon;
            if (typeof iconInfo === 'string') {
                iconRelativePath = iconInfo;
            } else if (typeof iconInfo === 'object') {
                const sizes = Object.keys(iconInfo).map(Number).sort((a, b) => b - a);
                const largestSize = sizes[0];
                if (largestSize) {
                    iconRelativePath = iconInfo[largestSize];
                }
            }
        }

        if (iconRelativePath) {
            const iconPath = path.join(extensionPath, iconRelativePath);
            if (fs.existsSync(iconPath)) {
                try {
                    const iconData = fs.readFileSync(iconPath);
                    const ext = path.extname(iconPath).toLowerCase();
                    const mimeType = ext === '.png' ? 'image/png' :
                        ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg' :
                            ext === '.svg' ? 'image/svg+xml' : 'image/png';
                    return `data:${mimeType};base64,${iconData.toString('base64')}`;
                } catch (error) {
                    console.error('Failed to read icon file:', iconPath, error);
                }
            }
        }

        return null;
    }

    async setupExtensionProtocol(extension) {
        const extensionScheme = `chrome-extension-${extension.id}`;

        if (this.registeredProtocols.has(extensionScheme)) {
            try {
                protocol.unregisterProtocol(extensionScheme);
            } catch (error) {
                console.warn('Failed to unregister existing protocol:', error.message);
            }
        }

        try {
            const success = protocol.registerFileProtocol(extensionScheme, (request, callback) => {
                const url = request.url.replace(`${extensionScheme}://`, '');
                const filePath = path.join(extension.path, url);
                
                // Security check - ensure file is within extension directory
                const resolvedPath = path.resolve(filePath);
                const extensionDir = path.resolve(extension.path);
                
                if (!resolvedPath.startsWith(extensionDir)) {
                    console.warn('Attempted to access file outside extension directory:', resolvedPath);
                    callback({ error: -6 }); // FILE_NOT_FOUND
                    return;
                }
                
                if (fs.existsSync(resolvedPath)) {
                    callback({ path: resolvedPath });
                } else {
                    console.warn('Extension file not found:', resolvedPath);
                    callback({ error: -6 }); // FILE_NOT_FOUND
                }
            });

            if (success) {
                this.registeredProtocols.add(extensionScheme);
                console.log('Successfully registered protocol:', extensionScheme);
            } else {
                console.warn('Failed to register protocol:', extensionScheme);
            }
        } catch (error) {
            console.error('Error registering protocol:', extensionScheme, error);
        }
    }

    async showExtensionPopup(extensionId, parentWindow, currentUrl = '') {
        console.log('showExtensionPopup called with extensionId:', extensionId);

        const extension = this.extensions.get(extensionId);
        if (!extension || !extension.popup) {
            console.log('No popup defined for extension:', extensionId);
            return { success: false, error: 'No popup defined for extension' };
        }

        // Fix: Derive currentUrl from parentWindow if not provided
        if (!currentUrl && parentWindow && parentWindow.webContents) {
            try {
                currentUrl = parentWindow.webContents.getURL();
                console.log('Derived currentUrl from parentWindow:', currentUrl);
            } catch (error) {
                console.warn('Failed to derive currentUrl from parentWindow:', error.message);
                currentUrl = '';  // Fallback to empty if derivation fails
            }
        }

        // Optional: Warn if still empty (helps catch caller issues)
        if (!currentUrl) {
            console.warn(`No currentUrl provided or derived for extension popup (${extensionId}). Tabs API may return empty URL.`);
        }

        if (this.popupWindows.has(extensionId)) {
            console.log('Closing existing popup for extension:', extensionId);
            try {
                const existingWindow = this.popupWindows.get(extensionId);
                if (!existingWindow.isDestroyed()) {
                    existingWindow.close();
                }
            } catch (error) {
                console.warn('Error closing existing popup:', error.message);
            }
            this.popupWindows.delete(extensionId);
        }

        const popupPath = path.join(extension.path, extension.popup);
        if (!fs.existsSync(popupPath)) {
            console.error('Popup file not found:', popupPath);
            return { success: false, error: 'Popup file not found' };
        }

        try {
            const popupWindow = new BrowserWindow({
                width: 400,
                height: 600,
                parent: parentWindow,
                modal: false,
                resizable: false,
                show: false,
                webPreferences: {
                    nodeIntegration: false,
                    contextIsolation: true,
                    enableRemoteModule: false,
                    webSecurity: false,
                    allowRunningInsecureContent: true,
                    preload: path.join(__dirname, 'extension-preload.js')
                }
            });

            let loadUrl;
            if (extension.electronId) {
                loadUrl = `chrome-extension://${extension.electronId}/${extension.popup}`;
            } else {
                loadUrl = `chrome-extension-${extension.id}://${extension.popup}`;
            }

            popupWindow.webContents.once('dom-ready', async () => {
                try {
                    await this.injectExtensionAPIs(popupWindow.webContents, extension, currentUrl, true);
                    console.log('Successfully injected APIs for popup');
                } catch (error) {
                    console.error('Failed to inject APIs for popup:', error);
                }
            });

            await popupWindow.loadURL(loadUrl);

            setTimeout(async () => {
                try {
                    if (!popupWindow.isDestroyed()) {
                        const sizeCode = `
                            JSON.stringify({
                                width: Math.max(200, Math.min(800, Math.ceil(document.documentElement.scrollWidth))),
                                height: Math.max(200, Math.min(600, Math.ceil(document.documentElement.scrollHeight)))
                            })
                        `;
                        const sizeJson = await popupWindow.webContents.executeJavaScript(sizeCode);
                        const parsedSize = JSON.parse(sizeJson);
                        popupWindow.setSize(parsedSize.width, parsedSize.height);
                        popupWindow.center();
                        popupWindow.show();
                    }
                } catch (error) {
                    console.error('Error resizing popup:', error);
                    if (!popupWindow.isDestroyed()) {
                        popupWindow.show();
                    }
                }
            }, 100);

            popupWindow.on('closed', () => {
                console.log('Popup window closed for extension:', extensionId);
                this.popupWindows.delete(extensionId);
            });

            this.popupWindows.set(extensionId, popupWindow);
            return { success: true };
        } catch (error) {
            console.error('Error in showExtensionPopup:', error);
            return { success: false, error: error.message };
        }
    }

    async unloadExtension(extensionId) {
        const extension = this.extensions.get(extensionId);
        if (extension) {
            if (this.popupWindows.has(extensionId)) {
                try {
                    const popupWindow = this.popupWindows.get(extensionId);
                    if (!popupWindow.isDestroyed()) {
                        popupWindow.close();
                    }
                } catch (error) {
                    console.warn('Error closing popup during unload:', error.message);
                }
                this.popupWindows.delete(extensionId);
            }

            if (extension.electronId) {
                try {
                    await session.defaultSession.removeExtension(extension.electronId);
                } catch (error) {
                    console.warn('Failed to remove extension from session:', error.message);
                }
            }

            const extensionScheme = `chrome-extension-${extension.id}`;
            if (this.registeredProtocols.has(extensionScheme)) {
                try {
                    protocol.unregisterProtocol(extensionScheme);
                    this.registeredProtocols.delete(extensionScheme);
                } catch (error) {
                    console.warn('Failed to unregister protocol:', error.message);
                }
            }

            if (this.extensionStores.has(extensionId)) {
                this.extensionStores.delete(extensionId);
            }

            this.extensions.delete(extensionId);
            this.loadedExtensions.delete(extensionId);

            // Update saved configuration
            this.saveConfiguration();

            console.log('Extension unloaded:', extension.name);
        }
    }

    getExtensions() {
        return Array.from(this.extensions.values());
    }

    getExtension(extensionId) {
        return this.extensions.get(extensionId);
    }

    generateExtensionId(name) {
        return name.toLowerCase().replace(/[^a-z0-9]/g, '');
    }

    async injectContentScripts(webview, url) {
        try {
            for (const extension of this.extensions.values()) {
                if (extension.electronId) continue;
                if (!extension.enabled) continue;

                const contentScripts = extension.manifest.content_scripts || [];

                for (const script of contentScripts) {
                    if (this.matchesUrl(url, script.matches)) {
                        if (script.css) {
                            for (const cssFile of script.css) {
                                try {
                                    const cssContent = await window.electronAPI.getExtensionFileContent(extension.id, cssFile);
                                    await webview.insertCSS(cssContent);
                                } catch (error) {
                                    console.error('Failed to inject CSS:', cssFile, error);
                                }
                            }
                        }

                        if (script.js) {
                            await this.injectExtensionAPIs(webview, extension, url);
                            for (const jsFile of script.js) {
                                try {
                                    const jsContent = await window.electronAPI.getExtensionFileContent(extension.id, jsFile);
                                    await webview.executeJavaScript(jsContent);
                                } catch (error) {
                                    console.error('Failed to inject JS:', jsFile, error);
                                }
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Failed to inject content scripts:', error);
        }
    }

    matchesUrl(url, patterns) {
        for (const pattern of patterns) {
            if (this.testPattern(url, pattern)) {
                return true;
            }
        }
        return false;
    }

    testPattern(url, pattern) {
        let regex = pattern
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*')
            .replace(/\?/g, '.');

        if (pattern.includes('://')) {
            regex = '^' + regex + '$';
        }

        try {
            return new RegExp(regex).test(url);
        } catch (error) {
            console.error('Invalid pattern:', pattern, error);
            return false;
        }
    }

    async cleanup() {
        console.log('Cleaning up ExtensionManager...');
        
        for (const [extensionId, popupWindow] of this.popupWindows) {
            try {
                if (!popupWindow.isDestroyed()) {
                    popupWindow.close();
                }
            } catch (error) {
                console.warn('Error closing popup during cleanup:', error.message);
            }
        }
        this.popupWindows.clear();

        for (const extensionId of this.extensions.keys()) {
            await this.unloadExtension(extensionId);
        }

        console.log('ExtensionManager cleanup complete');
    }
}

module.exports = ExtensionManager;


// main\extension-preload.js

const { contextBridge, ipcRenderer } = require('electron');

const api = {
    extensionStorageGet: (extensionId, keys) => ipcRenderer.invoke('extension-storage-get', extensionId, keys),
    extensionStorageSet: (extensionId, items) => ipcRenderer.invoke('extension-storage-set', extensionId, items),
    getExtensionFileContent: (extensionId, relativePath) => ipcRenderer.invoke('get-extension-file-content', extensionId, relativePath),
};

if (contextBridge) {
    contextBridge.exposeInMainWorld('electronAPI', api);
} else {
    window.electronAPI = api;
}


// main\history-manager.js

const Store = require('electron-store');

class HistoryManager {
    constructor() {
        this.store = new Store({
            name: 'history',
            defaults: {
                entries: []
            }
        });
    }

    addEntry(url, title) {
        const entries = this.store.get('entries', []);
        const entry = {
            url,
            title,
            timestamp: Date.now(),
            visitCount: 1
        };

        // Check if URL already exists
        const existingIndex = entries.findIndex(e => e.url === url);
        if (existingIndex >= 0) {
            entries[existingIndex].timestamp = Date.now();
            entries[existingIndex].visitCount++;
        } else {
            entries.unshift(entry);
        }

        // Keep only last 10000 entries
        if (entries.length > 10000) {
            entries.splice(10000);
        }

        this.store.set('entries', entries);
        return entry;
    }

    getEntries(limit = 1000) {
        return this.store.get('entries', []).slice(0, limit);
    }

    searchEntries(query) {
        const entries = this.store.get('entries', []);
        return entries.filter(entry => 
            entry.title.toLowerCase().includes(query.toLowerCase()) ||
            entry.url.toLowerCase().includes(query.toLowerCase())
        );
    }

    clearHistory() {
        this.store.set('entries', []);
    }

    removeEntry(url) {
        const entries = this.store.get('entries', []);
        const filteredEntries = entries.filter(entry => entry.url !== url);
        this.store.set('entries', filteredEntries);
    }
}

module.exports = HistoryManager;


// main\main.js

// main\main.js

const { app, BrowserWindow, ipcMain, session, dialog, Menu, shell } = require('electron');
const path = require('path');
const fs = require('fs');
const Store = require('electron-store');
const ExtensionManager = require('./extension-manager');

class NetBirdBrowser {
  constructor() {
    this.windows = new Map();
    this.extensions = new Map();
    this.extensionManager = new ExtensionManager();
    this.setupApp();
  }

  setupApp() {
    app.whenReady().then(async () => {
      await this.extensionManager.initializeFromConfig();
      this.createMainWindow();
      this.setupIPC();
      this.setupMenu();
      await this.loadExtensions();  // Await this as well for consistency
    });

    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });

    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        this.createMainWindow();
      }
    });
  }

  createMainWindow() {
    const mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js'),
        webSecurity: false,
        enableRemoteModule: false,
        webviewTag: true,
        allowRunningInsecureContent: true,
        experimentalFeatures: true,
        sandbox: false
      },
      titleBarStyle: process.platform === 'darwin' ? 'hiddenInset' : 'default',
      show: false,
      frame: true
    });

    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));

    mainWindow.once('ready-to-show', () => {
      mainWindow.show();
      if (process.env.NODE_ENV === 'development') {
        mainWindow.webContents.openDevTools();
      }
    });

    mainWindow.on('closed', () => {
      this.windows.delete('main');
    });

    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: 'deny' };
    });

    this.windows.set('main', mainWindow);
    return mainWindow;
  }

  setupIPC() {
    ipcMain.handle('create-tab', async (event, url) => {
      console.log('Creating tab with URL:', url);
      return { success: true, tabId: 'tab-' + Date.now() };
    });

    ipcMain.handle('close-tab', async (event, tabId) => {
      console.log('Closing tab:', tabId);
      return { success: true };
    });

    ipcMain.handle('navigate-tab', async (event, tabId, url) => {
      console.log('Navigating tab:', tabId, 'to:', url);
      return { success: true };
    });

    ipcMain.handle('get-history', async () => {
      return store.get('history', []);
    });

    ipcMain.handle('add-history', async (event, entry) => {
      const history = store.get('history', []);
      history.unshift(entry);
      if (history.length > 1000) history.pop();
      store.set('history', history);
      return { success: true };
    });

    ipcMain.handle('get-bookmarks', async () => {
      return store.get('bookmarks', []);
    });

    ipcMain.handle('add-bookmark', async (event, bookmark) => {
      const bookmarks = store.get('bookmarks', []);
      bookmarks.push(bookmark);
      store.set('bookmarks', bookmarks);
      return { success: true };
    });

    ipcMain.handle('load-extension', async (event, extensionPath) => {
      try {
        const result = await dialog.showOpenDialog({
          properties: ['openDirectory'],
          title: 'Select Extension Folder'
        });

        if (!result.canceled && result.filePaths.length > 0) {
          return await this.extensionManager.loadExtension(result.filePaths[0]);
        }
        return null;
      } catch (error) {
        console.error('Failed to load extension:', error);
        throw error;
      }
    });

    ipcMain.handle('get-extensions', async () => {
      return this.extensionManager.getExtensions();
    });

    ipcMain.handle('show-extension-popup', async (event, extensionId, currentUrl) => {
      console.log('IPC show-extension-popup called with extensionId:', extensionId, 'currentUrl:', currentUrl);
      try {
        const mainWindow = this.windows.get('main');
        if (!mainWindow) {
          console.error('Main window not found');
          return { success: false, error: 'Main window not found' };
        }
        const result = await this.extensionManager.showExtensionPopup(extensionId, mainWindow, currentUrl);
        console.log('IPC show-extension-popup response:', result);
        return result;
      } catch (error) {
        console.error('Failed to show extension popup:', error);
        return { success: false, error: error.message };
      }
    });

    ipcMain.handle('get-extension-file-content', async (event, extensionId, relativePath) => {
      try {
        const extension = this.extensionManager.getExtension(extensionId);
        if (!extension) {
          throw new Error('Extension not found');
        }
        const fullPath = path.join(extension.path, relativePath);
        if (!fs.existsSync(fullPath)) {
          throw new Error('File not found');
        }
        return fs.readFileSync(fullPath, 'utf8');
      } catch (error) {
        console.error('Failed to get extension file content:', error);
        throw error;
      }
    });

    ipcMain.handle('extension-storage-get', async (event, extensionId, keys) => {
      return netbird.extensionManager.getStorage(extensionId, keys);
    });

    ipcMain.handle('extension-storage-set', async (event, extensionId, items) => {
      await netbird.extensionManager.setStorage(extensionId, items);
      return { success: true };
    });

  // Update in main\main.js
// Replace the ipcMain.handle('get-extension-api-script', ...) with this:

ipcMain.handle('get-extension-api-script', async (event, extensionId, currentUrl = '') => {
  try {
    const extension = this.extensionManager.getExtension(extensionId);
    if (!extension) {
      throw new Error('Extension not found');
    }
    const safeExtension = JSON.parse(JSON.stringify(extension));
    if (!safeExtension.manifest || typeof safeExtension.manifest !== 'object') {
      throw new Error('Invalid extension manifest');
    }
    let manifestString = JSON.stringify(safeExtension.manifest);
    const escapedCurrentUrl = currentUrl.replace(/'/g, "\\'");
    const apiScript = `
      (function() {
        try {
          window.chrome = window.chrome || {};
          window.chrome.extension = window.chrome.extension || {};
          window.chrome.extension.getURL = window.chrome.extension.getURL || function(path) {
            return 'chrome-extension-${safeExtension.id}://' + path;
          };
          window.chrome.runtime = window.chrome.runtime || {};
          window.chrome.runtime.getManifest = window.chrome.runtime.getManifest || function() {
            return ${manifestString};
          };
          window.chrome.runtime.id = '${safeExtension.id}';
          window.chrome.runtime.lastError = undefined;
          window.chrome.runtime.sendMessage = function(...args) {
            let id, message, options, responseCallback;
            if (args.length === 1) {
              message = args[0];
            } else if (args.length === 2) {
              if (typeof args[1] === 'function') {
                message = args[0];
                responseCallback = args[1];
              } else {
                id = args[0];
                message = args[1];
              }
            } else if (args.length === 3) {
              if (typeof args[2] === 'function') {
                id = args[0];
                message = args[1];
                responseCallback = args[2];
              } else {
                id = args[0];
                message = args[1];
                options = args[2];
              }
            } else if (args.length === 4) {
              id = args[0];
              message = args[1];
              options = args[2];
              responseCallback = args[3];
            }
            if (responseCallback) {
              responseCallback({});
            } else {
              return Promise.resolve({});
            }
          };
          window.chrome.runtime.onMessage = window.chrome.runtime.onMessage || {
            addListener: function(fn) {},
            removeListener: function(fn) {},
            hasListener: function(fn) { return false; },
            hasListeners: function() { return false; }
          };
          window.chrome.runtime.onConnect = window.chrome.runtime.onConnect || {
            addListener: function(fn) {},
            removeListener: function(fn) {},
            hasListener: function(fn) { return false; },
            hasListeners: function() { return false; }
          };
          window.chrome.runtime.connect = window.chrome.runtime.connect || function(extensionId, connectInfo) {
            return {
              name: connectInfo ? connectInfo.name : '',
              postMessage: function(msg) {},
              disconnect: function() {},
              onDisconnect: {
                addListener: function(fn) {},
                removeListener: function(fn) {},
                hasListener: function(fn) { return false; }
              },
              onMessage: {
                addListener: function(fn) {},
                removeListener: function(fn) {},
                hasListener: function(fn) { return false; }
              }
            };
          };
          window.chrome.i18n = window.chrome.i18n || {};
          window.chrome.i18n.getMessage = window.chrome.i18n.getMessage || function(key, substitutions) {
            return key;
          };
          if (!window.browser) {
            window.browser = window.chrome;
          }
          window.chrome.storage = window.chrome.storage || {};
          window.chrome.storage.local = window.chrome.storage.local || {};
          window.chrome.storage.local.get = function(...args) {
            let keys = null, callback = null;
            if (args.length === 0) {
              keys = null;
            } else if (args.length === 1) {
              if (typeof args[0] === 'function') {
                callback = args[0];
                keys = null;
              } else {
                keys = args[0];
              }
            } else if (args.length === 2) {
              keys = args[0];
              callback = args[1];
            }
            const promise = window.electronAPI.extensionStorageGet('${safeExtension.id}', keys);
            if (typeof callback === 'function') {
              promise.then(result => callback(result)).catch(err => console.error('Storage get error:', err));
            } else {
              return promise;
            }
          };
          window.chrome.storage.local.set = function(...args) {
            let items = null, callback = null;
            if (args.length === 0) {
              items = {};
            } else if (args.length === 1) {
              if (typeof args[0] === 'function') {
                callback = args[0];
                items = {};
              } else {
                items = args[0];
              }
            } else if (args.length === 2) {
              items = args[0];
              callback = args[1];
            }
            const promise = window.electronAPI.extensionStorageSet('${safeExtension.id}', items);
            if (typeof callback === 'function') {
              promise.then(() => callback()).catch(err => console.error('Storage set error:', err));
            } else {
              return promise;
            }
          };
          window.chrome.tabs = window.chrome.tabs || {};
          window.chrome.tabs.query = function(queryInfo, callback) {
            if (typeof queryInfo === 'function') {
              callback = queryInfo;
              queryInfo = {};
            }
            const exec = () => {
              const result = [];
              const hasCurrent = (queryInfo.currentWindow === undefined || queryInfo.currentWindow) && (queryInfo.active === undefined || queryInfo.active);
              const currentUrl = '${escapedCurrentUrl}';
              if (hasCurrent && currentUrl) {
                result.push({
                  id: 1,
                  index: 0,
                  windowId: 1,
                  active: true,
                  url: currentUrl,
                  title: 'Current Tab'
                });
              }
              return result;
            };
            if (callback) {
              callback(exec());
            } else {
              return Promise.resolve(exec());
            }
          };
          window.chrome.tabs.getCurrent = function(callback) {
            const exec = () => undefined;
            if (callback) {
              callback(exec());
            } else {
              return Promise.resolve(exec());
            }
          };
        } catch (error) {
          console.error('Extension API injection failed:', error);
        }
      })();
    `;
    return apiScript;
  } catch (error) {
    console.error('Failed to get extension api script:', error);
    throw error;
  }
});

    ipcMain.handle('webview-permission', async (event, permission, origin) => {
      console.log('Webview permission requested:', permission, 'for:', origin);
      return true;
    });
  }

  setupMenu() {
    const template = [
      {
        label: 'File',
        submenu: [
          {
            label: 'New Tab',
            accelerator: 'CmdOrCtrl+T',
            click: () => {
              const mainWindow = this.windows.get('main');
              if (mainWindow) {
                mainWindow.webContents.send('create-new-tab');
              }
            }
          },
          {
            label: 'New Window',
            accelerator: 'CmdOrCtrl+N',
            click: () => {
              this.createMainWindow();
            }
          },
          { type: 'separator' },
          {
            label: 'Quit',
            accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
            click: () => {
              app.quit();
            }
          }
        ]
      },
      {
        label: 'View',
        submenu: [
          { role: 'reload' },
          { role: 'forceReload' },
          { role: 'toggleDevTools' },
          { type: 'separator' },
          { role: 'resetZoom' },
          { role: 'zoomIn' },
          { role: 'zoomOut' },
          { type: 'separator' },
          { role: 'togglefullscreen' }
        ]
      }
    ];

    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
  }

  async loadExtensions() {
    try {
      const extensionsPath = path.join(__dirname, '../extensions');
      console.log('Extensions path:', extensionsPath);

      if (!fs.existsSync(extensionsPath)) {
        console.log('Extensions directory does not exist, creating it...');
        fs.mkdirSync(extensionsPath, { recursive: true });
        return;
      }

      const files = await fs.promises.readdir(extensionsPath, { withFileTypes: true });
      const extensionFolders = files.filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);

      console.log('Found extension folders:', extensionFolders);

      for (const folder of extensionFolders) {
        const extensionDir = path.join(extensionsPath, folder);
        try {
          await this.extensionManager.loadExtension(extensionDir);
        } catch (error) {
          console.error(`Failed to load extension from ${folder}:`, error.message);
        }
      }
    } catch (error) {
      console.error('Failed to load extensions:', error);
    }
  }
}

const store = new Store();
const netbird = new NetBirdBrowser();


// main\preload.js

// main\preload.js

const { contextBridge, ipcRenderer } = require('electron');
const path = require('path');

const api = {
  createTab: (url) => ipcRenderer.invoke('create-tab', url),
  closeTab: (tabId) => ipcRenderer.invoke('close-tab', tabId),
  navigateTab: (tabId, url) => ipcRenderer.invoke('navigate-tab', tabId, url),
  getHistory: () => ipcRenderer.invoke('get-history'),
  addHistory: (entry) => ipcRenderer.invoke('add-history', entry),
  getBookmarks: () => ipcRenderer.invoke('get-bookmarks'),
  addBookmark: (bookmark) => ipcRenderer.invoke('add-bookmark', bookmark),
  loadExtension: (path) => ipcRenderer.invoke('load-extension', path),
  getExtensions: () => ipcRenderer.invoke('get-extensions'),
  extensionStorageGet: (extensionId, keys) => ipcRenderer.invoke('extension-storage-get', extensionId, keys),
  extensionStorageSet: (extensionId, items) => ipcRenderer.invoke('extension-storage-set', extensionId, items),
  getPreloadPath: () => path.join(__dirname, 'preload.js'),
  onCreateNewTab: (callback) => ipcRenderer.on('create-new-tab', callback),
  onTabUpdate: (callback) => ipcRenderer.on('tab-update', callback),
  onExtensionAction: (callback) => ipcRenderer.on('extension-action', callback),
  showExtensionPopup: (extensionId, currentUrl) => ipcRenderer.invoke('show-extension-popup', extensionId, currentUrl),
  getExtensionFileContent: (extensionId, relativePath) => ipcRenderer.invoke('get-extension-file-content', extensionId, relativePath),
  getExtensionApiScript: (extensionId, currentUrl) => ipcRenderer.invoke('get-extension-api-script', extensionId, currentUrl),
};

if (contextBridge) {
  contextBridge.exposeInMainWorld('electronAPI', api);
} else {
  window.electronAPI = api;
}


// renderer\app.js

class NetBirdApp {
    constructor() {
        this.tabs = new Map();
        this.activeTabId = null;
        this.tabCounter = 0;
        this.history = [];
        this.bookmarks = [];
        this.extensions = [];
        this.currentPanel = null;

        this.init();
    }

    async init() {
        this.bindEvents();
        await this.loadData();
        this.createInitialTab();
    }

    bindEvents() {
        document.getElementById('newTabBtn').addEventListener('click', () => {
            this.createNewTab();
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            this.goBack();
        });

        document.getElementById('forwardBtn').addEventListener('click', () => {
            this.goForward();
        });

        document.getElementById('refreshBtn').addEventListener('click', () => {
            this.refresh();
        });

        const urlInput = document.getElementById('urlInput');
        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.navigate(urlInput.value);
            }
        });

        document.getElementById('historyBtn').addEventListener('click', () => {
            this.togglePanel('history');
        });

        document.getElementById('bookmarksBtn').addEventListener('click', () => {
            this.togglePanel('bookmarks');
        });

        document.getElementById('extensionsBtn').addEventListener('click', () => {
            this.togglePanel('extensions');
        });

        if (window.electronAPI) {
            window.electronAPI.onCreateNewTab(() => {
                this.createNewTab();
            });
        }
    }

    async loadData() {
        try {
            if (window.electronAPI) {
                this.history = await window.electronAPI.getHistory();
                this.bookmarks = await window.electronAPI.getBookmarks();
                this.extensions = await window.electronAPI.getExtensions();
                this.renderExtensionButtons();
            } else {
                this.history = [];
                this.bookmarks = [];
                this.extensions = [];
                console.warn('Electron API not available, running in fallback mode');
            }
        } catch (error) {
            console.error('Failed to load data:', error);
            this.history = [];
            this.bookmarks = [];
            this.extensions = [];
        }
    }

    createInitialTab() {
        this.createNewTab('https://www.google.com');
    }

    createNewTab(url = 'https://www.google.com') {
        const tabId = `tab-${++this.tabCounter}`;
        const tab = {
            id: tabId,
            url: url,
            title: 'New Tab',
            favicon: null,
            canGoBack: false,
            canGoForward: false,
            isLoading: false
        };

        this.tabs.set(tabId, tab);
        this.renderTab(tab);
        this.switchToTab(tabId);

        if (url === 'netbird://welcome') {
            this.showWelcomeScreen();
        } else {
            this.navigate(url);
        }
    }

    renderTab(tab) {
        const tabElement = document.createElement('div');
        tabElement.className = 'tab-item';
        tabElement.dataset.tabId = tab.id;

        tabElement.innerHTML = `
            <img class="tab-favicon" src="${tab.favicon || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" fill="%23999"/></svg>'}" alt="">
            <span class="tab-title">${tab.title}</span>
            <button class="tab-close" onclick="app.closeTab('${tab.id}')">
                <svg width="12" height="12" viewBox="0 0 12 12">
                    <path d="M9 3L3 9M3 3L9 9" stroke="currentColor" stroke-width="2"/>
                </svg>
            </button>
        `;

        tabElement.addEventListener('click', (e) => {
            if (!e.target.closest('.tab-close')) {
                this.switchToTab(tab.id);
            }
        });

        document.getElementById('tabsContainer').appendChild(tabElement);
    }

    switchToTab(tabId) {
        document.querySelectorAll('.tab-item').forEach(tab => {
            tab.classList.remove('active');
        });

        const tabElement = document.querySelector(`[data-tab-id="${tabId}"]`);
        if (tabElement) {
            tabElement.classList.add('active');
        }

        this.activeTabId = tabId;
        const tab = this.tabs.get(tabId);
        if (tab) {
            this.updateUI(tab);
            this.showWebview(tabId);

            setTimeout(() => {
                const webview = document.getElementById(`webview-${tabId}`);
                if (webview) {
                    this.resizeWebview(webview);
                }
            }, 100);
        }
    }

    closeTab(tabId) {
        const tabElement = document.querySelector(`[data-tab-id="${tabId}"]`);
        if (tabElement) {
            tabElement.remove();
        }

        const webview = document.getElementById(`webview-${tabId}`);
        if (webview) {
            webview.remove();
        }

        this.tabs.delete(tabId);

        if (this.activeTabId === tabId) {
            const remainingTabs = Array.from(this.tabs.keys());
            if (remainingTabs.length > 0) {
                this.switchToTab(remainingTabs[0]);
            } else {
                this.showWelcomeScreen();
            }
        }
    }

    navigate(url) {
        if (!this.activeTabId) return;

        if (url === 'netbird://welcome' || url === '') {
            this.showWelcomeScreen();
            return;
        }

        url = url.trim();
        if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('file://')) {
            if (url.includes('.') && !url.includes(' ')) {
                url = 'https://' + url;
            } else {
                url = 'https://www.google.com/search?q=' + encodeURIComponent(url);
            }
        }

        const tab = this.tabs.get(this.activeTabId);
        if (tab) {
            tab.url = url;
            tab.isLoading = true;
            this.updateUI(tab);
            this.navigateWebview(this.activeTabId, url);
        }
    }

    navigateWebview(tabId, url) {
        let webview = document.getElementById(`webview-${tabId}`);

        if (!webview) {
            webview = document.createElement('webview');
            webview.id = `webview-${tabId}`;
            const preloadPath = window.electronAPI.getPreloadPath();  // Get path from exposed API
            webview.setAttribute('webpreferences', `preload=${preloadPath}, contextIsolation=true, nodeIntegration=false, enableRemoteModule=false, webSecurity=false, allowRunningInsecureContent=true`);
            webview.setAttribute('allowpopups', 'true');
            webview.style.cssText = `
                width: 100% !important;
                height: 100% !important;
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                border: none !important;
                outline: none !important;
                background: white;
            `;

            webview.setAttribute('allowpopups', 'true');


            webview.addEventListener('did-stop-loading', () => {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.isLoading = false;
                    tab.title = webview.getTitle() || 'Untitled';
                    this.updateUI(tab);
                    this.updateTabTitle(tabId, tab.title);
                }
                this.resizeWebview(webview);
                this.injectContentScripts(webview, webview.getURL());
            });

            webview.addEventListener('dom-ready', () => {
                webview.executeJavaScript(`
                    document.documentElement.style.height = '100vh';
                    document.body.style.height = '100vh';
                    document.body.style.margin = '0';
                    document.body.style.padding = '0';
                    document.body.style.overflow = 'auto';
                `).catch(err => console.log('Could not execute sizing script:', err));
            });

            webview.addEventListener('did-start-loading', () => {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.isLoading = true;
                    this.updateUI(tab);
                }
            });

            webview.addEventListener('did-stop-loading', () => {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.isLoading = false;
                    tab.title = webview.getTitle() || 'Untitled';
                    this.updateUI(tab);
                    this.updateTabTitle(tabId, tab.title);
                }
                this.resizeWebview(webview);
            });

            webview.addEventListener('did-navigate', (e) => {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.url = e.url;
                    tab.canGoBack = webview.canGoBack();
                    tab.canGoForward = webview.canGoForward();
                    this.updateUI(tab);
                    this.addToHistory(e.url, tab.title);
                }
            });

            webview.addEventListener('page-title-updated', (e) => {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.title = e.title;
                    this.updateTabTitle(tabId, e.title);
                }
            });

            webview.addEventListener('page-favicon-updated', (e) => {
                const tab = this.tabs.get(tabId);
                if (tab && e.favicons && e.favicons.length > 0) {
                    tab.favicon = e.favicons[0];
                    this.updateTabFavicon(tabId, tab.favicon);
                }
            });

            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => {
                    this.resizeWebview(webview);
                });
                resizeObserver.observe(document.getElementById('webviewContainer'));
            }

            document.getElementById('webviewContainer').appendChild(webview);
        }

        webview.src = url;
        this.showWebview(tabId);
    }

    resizeWebview(webview) {
        if (webview && webview.style.display !== 'none') {
            const container = document.getElementById('webviewContainer');
            const rect = container.getBoundingClientRect();
            webview.style.width = rect.width + 'px';
            webview.style.height = rect.height + 'px';
            setTimeout(() => {
                try {
                    webview.executeJavaScript(`
                        window.dispatchEvent(new Event('resize'));
                    `).catch(err => console.log('Could not dispatch resize event:', err));
                } catch (err) {
                    console.log('Could not execute resize script:', err);
                }
            }, 100);
        }
    }

    showWebview(tabId) {
        document.querySelectorAll('webview').forEach(wv => {
            wv.style.display = 'none';
        });
        document.getElementById('welcomeScreen').style.display = 'none';
        const webview = document.getElementById(`webview-${tabId}`);
        if (webview) {
            webview.style.display = 'flex';
            setTimeout(() => {
                this.resizeWebview(webview);
            }, 50);
        }
    }

    showWelcomeScreen() {
        document.querySelectorAll('webview').forEach(wv => {
            wv.style.display = 'none';
        });
        document.getElementById('welcomeScreen').style.display = 'flex';
        document.getElementById('urlInput').value = '';
        this.updateNavigationButtons(false, false);
    }

    updateUI(tab) {
        document.getElementById('urlInput').value = tab.url === 'netbird://welcome' ? '' : tab.url;
        this.updateNavigationButtons(tab.canGoBack, tab.canGoForward);
        const container = document.getElementById('webviewContainer');
        const existingIndicator = container.querySelector('.loading-indicator');
        if (tab.isLoading && !existingIndicator) {
            const indicator = document.createElement('div');
            indicator.className = 'loading-indicator';
            container.appendChild(indicator);
        } else if (!tab.isLoading && existingIndicator) {
            existingIndicator.remove();
        }
    }

    updateNavigationButtons(canGoBack, canGoForward) {
        document.getElementById('backBtn').disabled = !canGoBack;
        document.getElementById('forwardBtn').disabled = !canGoForward;
    }

    updateTabTitle(tabId, title) {
        const tabElement = document.querySelector(`[data-tab-id="${tabId}"] .tab-title`);
        if (tabElement) {
            tabElement.textContent = title || 'Untitled';
        }
    }

    updateTabFavicon(tabId, favicon) {
        const faviconElement = document.querySelector(`[data-tab-id="${tabId}"] .tab-favicon`);
        if (faviconElement && favicon) {
            faviconElement.src = favicon;
        }
    }

    goBack() {
        if (this.activeTabId) {
            const webview = document.getElementById(`webview-${this.activeTabId}`);
            if (webview && webview.canGoBack()) {
                webview.goBack();
            }
        }
    }

    goForward() {
        if (this.activeTabId) {
            const webview = document.getElementById(`webview-${this.activeTabId}`);
            if (webview && webview.canGoForward()) {
                webview.goForward();
            }
        }
    }

    refresh() {
        if (this.activeTabId) {
            const webview = document.getElementById(`webview-${this.activeTabId}`);
            if (webview) {
                webview.reload();
            }
        }
    }

    async addToHistory(url, title) {
        const entry = {
            url: url,
            title: title || 'Untitled',
            timestamp: Date.now()
        };
        this.history.unshift(entry);
        if (this.history.length > 1000) {
            this.history.pop();
        }
        try {
            if (window.electronAPI) {
                await window.electronAPI.addHistory(entry);
            }
        } catch (error) {
            console.error('Failed to save history:', error);
        }
    }

    togglePanel(panelType) {
        const panel = document.getElementById('sidebarPanel');
        if (this.currentPanel === panelType) {
            panel.classList.remove('active');
            this.currentPanel = null;
            return;
        }
        this.currentPanel = panelType;
        panel.classList.add('active');
        switch (panelType) {
            case 'history':
                this.renderHistoryPanel();
                break;
            case 'bookmarks':
                this.renderBookmarksPanel();
                break;
            case 'extensions':
                this.renderExtensionsPanel();
                break;
        }
    }

    renderHistoryPanel() {
        const panel = document.getElementById('sidebarPanel');
        panel.innerHTML = `
            <div style="padding: 16px; border-bottom: 1px solid var(--border-color); font-weight: 600;">
                History
            </div>
            <div class="panel-content">
                ${this.history.slice(0, 50).map(entry => `
                    <div class="panel-item" onclick="app.navigate('${entry.url}')">
                        <div class="panel-item-title">${entry.title}</div>
                        <div class="panel-item-url">${entry.url}</div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    renderBookmarksPanel() {
        const panel = document.getElementById('sidebarPanel');
        panel.innerHTML = `
            <div style="padding: 16px; border-bottom: 1px solid var(--border-color); font-weight: 600;">
                Bookmarks
            </div>
            <div class="panel-content">
                ${this.bookmarks.map(bookmark => `
                    <div class="panel-item" onclick="app.navigate('${bookmark.url}')">
                        <div class="panel-item-title">${bookmark.title}</div>
                        <div class="panel-item-url">${bookmark.url}</div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    renderExtensionsPanel() {
        const panel = document.getElementById('sidebarPanel');
        panel.innerHTML = `
            <div style="padding: 16px; border-bottom: 1px solid var(--border-color); font-weight: 600;">
                Extensions
            </div>
            <div class="panel-content">
                ${this.extensions.map(ext => `
                    <div class="panel-item">
                        <div class="panel-item-title">${ext.name}</div>
                        <div class="panel-item-url">${ext.description}</div>
                    </div>
                `).join('')}
                <div class="panel-item" onclick="app.loadExtension()" style="color: var(--primary-color);">
                    <div class="panel-item-title">+ Load Extension</div>
                </div>
            </div>
        `;
    }

    renderExtensionButtons() {
        const container = document.getElementById('extensionActions');
        container.innerHTML = '';
        this.extensions.forEach(extension => {
            if (extension.icon || extension.manifest.browser_action?.default_icon) {
                const button = document.createElement('button');
                button.className = 'extension-btn';
                button.title = extension.name;
                let iconPath = extension.icon || extension.manifest.browser_action?.default_icon;
                if (typeof iconPath === 'object') {
                    const sizes = Object.keys(iconPath).map(Number).sort((a, b) => b - a);
                    iconPath = iconPath[sizes[0]];
                }
                const iconUrl = extension.icon ? extension.icon : `file://${extension.path}/${iconPath}`;
                button.innerHTML = `
                    <img src="${iconUrl}" 
                         width="16" height="16" alt="${extension.name}"
                         onerror="this.src='data:image/svg+xml,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"16\\" height=\\"16\\" viewBox=\\"0 0 16 16\\"><rect width=\\"16\\" height=\\"16\\" fill=\\"%23666\\"/></svg>'">
                `;
                button.addEventListener('click', () => {
                    this.showExtensionPopup(extension.id);
                });
                container.appendChild(button);
            }
        });
    }

    async showExtensionPopup(extensionId) {
        console.log('Calling showExtensionPopup for extension:', extensionId);
        try {
            if (window.electronAPI) {
                const tab = this.tabs.get(this.activeTabId);
                const currentUrl = tab ? tab.url : '';
                const result = await window.electronAPI.showExtensionPopup(extensionId, currentUrl);
                console.log('Received IPC response:', result);
                if (!result.success) {
                    console.error('Failed to show extension popup:', result.error);
                    alert(`Failed to show extension popup: ${result.error}`);
                } else {
                    console.log('Extension popup shown successfully for:', extensionId);
                }
            } else {
                console.warn('Electron API not available for showing extension popup');
                alert('Extension popup requires Electron environment');
            }
        } catch (error) {
            console.error('Error showing extension popup:', error);
            alert(`Error showing extension popup: ${error.message}`);
        }
    }

    // Add these methods
    matchesUrl(url, patterns) {
        for (const pattern of patterns) {
            if (this.testPattern(url, pattern)) {
                return true;
            }
        }
        return false;
    }

    testPattern(url, pattern) {
        let regex = pattern
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*')
            .replace(/\?/g, '.');
        if (pattern.includes('://')) {
            regex = '^' + regex + '$';
        }
        try {
            return new RegExp(regex).test(url);
        } catch (error) {
            console.error('Invalid pattern:', pattern, error);
            return false;
        }
    }

    async injectExtensionAPIs(webview, extension, currentUrl) {
        try {
            const apiScript = await window.electronAPI.getExtensionApiScript(extension.id, currentUrl);
            await webview.executeJavaScript(apiScript);
        } catch (error) {
            console.error('Failed to inject APIs for extension:', extension.id, error);
        }
    }

 async injectContentScripts(webview, url) {
    try {
        for (const extension of this.extensions) {
            if (!extension.enabled) continue;

            const contentScripts = extension.manifest.content_scripts || [];

            for (const script of contentScripts) {
                if (this.matchesUrl(url, script.matches)) {
                    if (script.css) {
                        for (const cssFile of script.css) {
                            try {
                                const cssContent = await window.electronAPI.getExtensionFileContent(extension.id, cssFile);
                                await webview.insertCSS(cssContent);
                            } catch (error) {
                                console.error('Failed to inject CSS:', cssFile, error);
                            }
                        }
                    }

                    if (script.js) {
                        await this.injectExtensionAPIs(webview, extension, url);
                        for (const jsFile of script.js) {
                            try {
                                const jsContent = await window.electronAPI.getExtensionFileContent(extension.id, jsFile);
                                
                                // Validate content before injection
                                if (!jsContent || jsContent.trim() === '') {
                                    console.warn('Empty or invalid script content for:', jsFile);
                                    continue;
                                }
                                
                                console.log(`Attempting to inject ${jsFile} for extension ${extension.id}`);
                                console.log('Script content preview:', jsContent.substring(0, 300));
                                
                                // Create a more robust injection method
                                const injectionCode = `
                                    (function() {
                                        try {
                                            console.log('Injecting content script: ${jsFile}');
                                            
                                            // Check if DOM is ready
                                            if (document.readyState === 'loading') {
                                                document.addEventListener('DOMContentLoaded', function() {
                                                    executeContentScript();
                                                });
                                            } else {
                                                executeContentScript();
                                            }
                                            
                                            function executeContentScript() {
                                                try {
                                                    ${jsContent}
                                                    console.log('Successfully executed content script: ${jsFile}');
                                                } catch (scriptError) {
                                                    console.error('Content script execution error in ${jsFile}:', scriptError);
                                                    console.error('Error stack:', scriptError.stack);
                                                }
                                            }
                                            
                                        } catch (wrapperError) {
                                            console.error('Content script wrapper error for ${jsFile}:', wrapperError);
                                            console.error('Wrapper error stack:', wrapperError.stack);
                                        }
                                    })();
                                `;
                                
                                await webview.executeJavaScript(injectionCode);
                                console.log('Successfully injected wrapper for:', jsFile);
                                
                            } catch (error) {
                                console.error('Failed to inject JS:', jsFile, error);
                                console.error('Extension:', extension.id);
                                console.error('URL:', url);
                                
                                // Try to get more details about the error
                                if (error.message.includes('Script failed to execute')) {
                                    console.error('This usually means there\'s a syntax error or runtime error in the script');
                                    console.error('Consider checking the content script for:');
                                    console.error('- Syntax errors');
                                    console.error('- Missing dependencies');
                                    console.error('- DOM elements that don\'t exist yet');
                                    console.error('- Async operations without proper handling');
                                }
                            }
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.error('Failed to inject content scripts:', error);
    }
}

// Alternative method using try-catch for script validation
async injectContentScriptsSafe(webview, url) {
    try {
        for (const extension of this.extensions) {
            if (!extension.enabled) continue;

            const contentScripts = extension.manifest.content_scripts || [];

            for (const script of contentScripts) {
                if (this.matchesUrl(url, script.matches)) {
                    if (script.js) {
                        await this.injectExtensionAPIs(webview, extension, url);
                        for (const jsFile of script.js) {
                            try {
                                const jsContent = await window.electronAPI.getExtensionFileContent(extension.id, jsFile);
                                
                                // Validate content
                                if (!jsContent || jsContent.trim() === '') {
                                    console.warn('Empty script content for:', jsFile);
                                    continue;
                                }
                                
                                // Test script syntax before injection
                                try {
                                    new Function(jsContent);
                                    console.log('Script syntax validation passed for:', jsFile);
                                } catch (syntaxError) {
                                    console.error('Script syntax error in', jsFile, ':', syntaxError);
                                    continue;
                                }
                                
                                // Use a more careful injection approach
                                const safeInjectionCode = `
                                    (function() {
                                        'use strict';
                                        
                                        // Create isolated scope for content script
                                        const contentScriptScope = {
                                            window: window,
                                            document: document,
                                            console: console,
                                            setTimeout: setTimeout,
                                            setInterval: setInterval,
                                            clearTimeout: clearTimeout,
                                            clearInterval: clearInterval
                                        };
                                        
                                        // Execute in try-catch with detailed error reporting
                                        try {
                                            const executeScript = function() {
                                                ${jsContent}
                                            };
                                            
                                            // Wait for DOM if needed
                                            if (document.readyState === 'loading') {
                                                document.addEventListener('DOMContentLoaded', executeScript);
                                            } else {
                                                executeScript();
                                            }
                                            
                                        } catch (error) {
                                            console.error('Content script error in ${jsFile}:', {
                                                message: error.message,
                                                stack: error.stack,
                                                name: error.name,
                                                line: error.lineNumber,
                                                column: error.columnNumber
                                            });
                                        }
                                    })();
                                `;
                                
                                await webview.executeJavaScript(safeInjectionCode);
                                console.log('Successfully injected:', jsFile);
                                
                            } catch (error) {
                                console.error('Injection failed for:', jsFile, error);
                            }
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.error('Content script injection failed:', error);
    }
}

// Debug method to inspect what's actually in the content script
async debugContentScript(extensionId, jsFile) {
    try {
        const jsContent = await window.electronAPI.getExtensionFileContent(extensionId, jsFile);
        console.log('=== DEBUG CONTENT SCRIPT ===');
        console.log('Extension:', extensionId);
        console.log('File:', jsFile);
        console.log('Content length:', jsContent.length);
        console.log('Content preview:', jsContent.substring(0, 500));
        console.log('Contains import:', /\bimport\b/.test(jsContent));
        console.log('Contains export:', /\bexport\b/.test(jsContent));
        console.log('Contains require:', /\brequire\b/.test(jsContent));
        console.log('Contains chrome.*:', /chrome\.\w+/.test(jsContent));
        console.log('Contains browser.*:', /browser\.\w+/.test(jsContent));
        console.log('==============================');
        
        // Try to parse as JavaScript to check for syntax errors
        try {
            new Function(jsContent);
            console.log('✓ Script syntax is valid');
        } catch (syntaxError) {
            console.error('✗ Script syntax error:', syntaxError);
        }
        
        return jsContent;
    } catch (error) {
        console.error('Failed to debug content script:', error);
        return null;
    }
}

// Method to enable console message forwarding from webview
enableConsoleDebugging(webview) {
    webview.addEventListener('console-message', (e) => {
        console.log(`[WebView Console] [${e.level}] ${e.message}`);
        if (e.sourceId) {
            console.log(`[WebView Console] Source: ${e.sourceId}:${e.line}`);
        }
    });
    
    webview.addEventListener('dom-ready', () => {
        console.log('WebView DOM ready');
    });
}

// Method to check if content script dependencies are available
async checkContentScriptDependencies(webview, extensionId) {
    try {
        const checkCode = `
            (function() {
                const report = {
                    chrome: typeof chrome !== 'undefined',
                    browser: typeof browser !== 'undefined',
                    document: typeof document !== 'undefined',
                    window: typeof window !== 'undefined',
                    jQuery: typeof $ !== 'undefined' || typeof jQuery !== 'undefined',
                    readyState: document.readyState,
                    url: window.location.href,
                    timestamp: Date.now()
                };
                
                console.log('Content script environment check for ${extensionId}:', report);
                return report;
            })();
        `;
        
        const result = await webview.executeJavaScript(checkCode);
        console.log('Environment check result:', result);
        return result;
    } catch (error) {
        console.error('Failed to check content script dependencies:', error);
        return null;
    }
}
    async loadExtension() {
        try {
            if (window.electronAPI) {
                const result = await window.electronAPI.loadExtension();
                if (result) {
                    this.extensions.push(result);
                    this.renderExtensionButtons();
                    this.renderExtensionsPanel();
                }
            } else {
                alert('Extension loading requires Electron environment');
            }
        } catch (error) {
            console.error('Failed to load extension:', error);
            alert('Failed to load extension: ' + error.message);
        }
    }

    async bookmarkCurrentPage() {
        if (!this.activeTabId) return;
        const tab = this.tabs.get(this.activeTabId);
        if (tab && tab.url !== 'netbird://welcome') {
            const bookmark = {
                url: tab.url,
                title: tab.title,
                timestamp: Date.now()
            };
            this.bookmarks.push(bookmark);
            try {
                if (window.electronAPI) {
                    await window.electronAPI.addBookmark(bookmark);
                }
            } catch (error) {
                console.error('Failed to save bookmark:', error);
            }
        }
    }
}

function createNewTab(url) {
    app.createNewTab(url);
}

function showHistory() {
    app.togglePanel('history');
}

const app = new NetBirdApp();

document.addEventListener('keydown', (e) => {
    if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
            case 't':
                e.preventDefault();
                app.createNewTab();
                break;
            case 'w':
                e.preventDefault();
                if (app.activeTabId) {
                    app.closeTab(app.activeTabId);
                }
                break;
            case 'r':
                e.preventDefault();
                app.refresh();
                break;
            case 'l':
                e.preventDefault();
                document.getElementById('urlInput').focus();
                document.getElementById('urlInput').select();
                break;
            case 'd':
                e.preventDefault();
                app.bookmarkCurrentPage();
                break;
        }
    }
});


// renderer\index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NetBird Browser</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="app-container">
    <div class="title-bar">
      <div class="title-bar-controls">
        <span class="app-title">NetBird</span>
      </div>
    </div>
    
    <div class="main-content">
      <div class="sidebar">
        <div class="sidebar-header">
          <button class="new-tab-btn" id="newTabBtn">
            <svg width="16" height="16" viewBox="0 0 16 16">
              <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2"/>
            </svg>
          </button>
          <div class="sidebar-actions">
            <button class="action-btn" id="historyBtn">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <path d="M8 2C11.314 2 14 4.686 14 8C14 11.314 11.314 14 8 14C4.686 14 2 11.314 2 8C2 6.5 2.5 5.1 3.4 4" stroke="currentColor" stroke-width="2" fill="none"/>
                <path d="M8 4V8L11 11" stroke="currentColor" stroke-width="2" fill="none"/>
              </svg>
            </button>
            <button class="action-btn" id="bookmarksBtn">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <path d="M3 2V14L8 10L13 14V2H3Z" stroke="currentColor" stroke-width="2" fill="none"/>
              </svg>
            </button>
            <button class="action-btn" id="extensionsBtn">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <path d="M8 2L10 6L14 6L11 9L12 14L8 11L4 14L5 9L2 6L6 6L8 2Z" stroke="currentColor" stroke-width="2" fill="none"/>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="tabs-container" id="tabsContainer">
          <!-- Vertical tabs will be added here -->
        </div>
        
        <div class="sidebar-panel" id="sidebarPanel">
          <!-- History, bookmarks, extensions panels -->
        </div>
      </div>
      
      <div class="content-area">
        <div class="address-bar">
          <div class="navigation-controls">
            <button class="nav-btn" id="backBtn">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <path d="M10 2L4 8L10 14" stroke="currentColor" stroke-width="2" fill="none"/>
              </svg>
            </button>
            <button class="nav-btn" id="forwardBtn">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <path d="M6 2L12 8L6 14" stroke="currentColor" stroke-width="2" fill="none"/>
              </svg>
            </button>
            <button class="nav-btn" id="refreshBtn">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <path d="M14 8C14 11.314 11.314 14 8 14C4.686 14 2 11.314 2 8C2 4.686 4.686 2 8 2C10.5 2 12.5 3.5 13.5 5.5M13.5 5.5V2M13.5 5.5H10" stroke="currentColor" stroke-width="2" fill="none"/>
              </svg>
            </button>
          </div>
          
          <div class="url-input-container">
            <input type="text" class="url-input" id="urlInput" placeholder="Enter URL or search...">
            <button class="secure-indicator" id="secureIndicator">
              <svg width="14" height="14" viewBox="0 0 14 14">
                <path d="M3.5 6V4.5C3.5 2.5 5 1 7 1C9 1 10.5 2.5 10.5 4.5V6M2 6H12V12H2V6Z" stroke="currentColor" stroke-width="1.5" fill="none"/>
              </svg>
            </button>
          </div>
          
          <div class="extension-actions" id="extensionActions"></div>
        </div>
        
        <div class="webview-container" id="webviewContainer">
          <div class="welcome-screen" id="welcomeScreen">
            <div class="welcome-content">
              <h1>Welcome to NetBird</h1>
              <p>Your fast, secure, and modern browser</p>
              <div class="quick-actions">
                <button class="quick-action" onclick="createNewTab('https://google.com')">
                  <svg width="24" height="24" viewBox="0 0 24 24">
                    <path d="M21 16V8C21 6.9 20.1 6 19 6H5C3.9 6 3 6.9 3 8V16C3 17.1 3.9 18 5 18H19C20.1 18 21 17.1 21 16Z" stroke="currentColor" stroke-width="2" fill="none"/>
                    <path d="M7 10L12 13L17 10" stroke="currentColor" stroke-width="2" fill="none"/>
                  </svg>
                  Search
                </button>
                <button class="quick-action" onclick="showHistory()">
                  <svg width="24" height="24" viewBox="0 0 24 24">
                    <path d="M12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22C6.477 22 2 17.523 2 12C2 7.5 5 3.5 9 2.5" stroke="currentColor" stroke-width="2" fill="none"/>
                    <path d="M12 6V12L16 16" stroke="currentColor" stroke-width="2" fill="none"/>
                  </svg>
                  History
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <script src="app.js"></script>
  </body>
</html>


// renderer\styles.css

:root {
    --primary-color: #2563eb;
    --secondary-color: #1e40af;
    --accent-color: #3b82f6;
    --bg-primary: #ffffff;
    --bg-secondary: #f8fafc;
    --bg-tertiary: #f1f5f9;
    --text-primary: #1e293b;
    --text-secondary: #64748b;
    --border-color: #e2e8f0;
    --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.1);
    --border-radius: 8px;
    --transition: all 0.2s ease;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    height: 100%;
    overflow: hidden;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
}

.app-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    min-height: 100vh;
}

.title-bar {
    height: 32px;
    background: var(--bg-secondary);
    display: flex;
    align-items: center;
    padding: 0 16px;
    border-bottom: 1px solid var(--border-color);
    -webkit-app-region: drag;
    flex-shrink: 0;
}

.title-bar-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.app-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-secondary);
}

.main-content {
    display: flex;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}

.sidebar {
    width: 250px;
    background: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    flex-shrink: 0;
}

.sidebar-header {
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
}

.new-tab-btn {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    align-items: center;
    gap: 4px;
}

.new-tab-btn:hover {
    background: var(--secondary-color);
}

.sidebar-actions {
    display: flex;
    gap: 4px;
}

.action-btn {
    background: transparent;
    border: none;
    padding: 8px;
    border-radius: var(--border-radius);
    cursor: pointer;
    color: var(--text-secondary);
    transition: var(--transition);
}

.action-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.tabs-container {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    min-height: 0;
}

.tab-item {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 4px;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
}

.tab-item:hover {
    background: var(--bg-tertiary);
}

.tab-item.active {
    background: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}

.tab-favicon {
    width: 16px;
    height: 16px;
    margin-right: 8px;
    border-radius: 2px;
}

.tab-title {
    flex: 1;
    font-size: 13px;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.tab-close {
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    color: inherit;
    opacity: 0.7;
    transition: var(--transition);
}

.tab-close:hover {
    opacity: 1;
}

.content-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-height: 0;
}

.address-bar {
    height: 60px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    padding: 0 16px;
    gap: 12px;
    flex-shrink: 0;
}

.navigation-controls {
    display: flex;
    gap: 4px;
}

.nav-btn {
    background: transparent;
    border: none;
    padding: 8px;
    border-radius: var(--border-radius);
    cursor: pointer;
    color: var(--text-secondary);
    transition: var(--transition);
}

.nav-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.nav-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.url-input-container {
    flex: 1;
    display: flex;
    align-items: center;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    padding: 0 12px;
    height: 36px;
    transition: var(--transition);
}

.url-input-container:focus-within {
    border-color: var(--accent-color);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.url-input {
    flex: 1;
    border: none;
    outline: none;
    font-size: 14px;
    background: transparent;
    color: var(--text-primary);
}

.secure-indicator {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 4px;
}

.extension-actions {
    display: flex;
    gap: 4px;
}

.extension-btn {
    background: transparent;
    border: none;
    padding: 8px;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
}

.extension-btn:hover {
    background: var(--bg-tertiary);
}

.webview-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    min-height: 0;
    display: flex;
    flex-direction: column;
}

.webview-container webview {
    width: 100%;
    height: 100%;
    border: none;
    flex: 1;
    min-height: 0;
}

.welcome-screen {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    flex: 1;
}

.welcome-content {
    text-align: center;
    max-width: 400px;
    padding: 40px;
}

.welcome-content h1 {
    font-size: 32px;
    font-weight: 700;
    margin-bottom: 16px;
}

.welcome-content p {
    font-size: 16px;
    opacity: 0.9;
    margin-bottom: 32px;
}

.quick-actions {
    display: flex;
    gap: 16px;
    justify-content: center;
}

.quick-action {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 16px 24px;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    min-width: 120px;
}

.quick-action:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
}

.sidebar-panel {
    max-height: 200px;
    overflow-y: auto;
    background: var(--bg-primary);
    border-top: 1px solid var(--border-color);
    display: none;
    flex-shrink: 0;
}

.sidebar-panel.active {
    display: block;
}

.panel-item {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: var(--transition);
}

.panel-item:hover {
    background: var(--bg-tertiary);
}

.panel-item-title {
    font-size: 13px;
    font-weight: 500;
    margin-bottom: 4px;
}

.panel-item-url {
    font-size: 12px;
    color: var(--text-secondary);
}

.loading-indicator {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--accent-color);
    transform-origin: left;
    animation: loading 2s infinite;
    z-index: 1000;
}

@keyframes loading {
    0% { transform: scaleX(0); }
    50% { transform: scaleX(0.5); }
    100% { transform: scaleX(1); }
}

